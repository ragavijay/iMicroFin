create database amf_db;
use amf_db;
-- Version 2.0 (No Change)
CREATE TABLE AppUser (
    UserId VARCHAR(20),
    UserName VARCHAR(40),
    Passwd VARCHAR(16),
    UserType CHAR(1),
    EMailId VARCHAR(50),
    Phone CHAR(10),
    UserActive CHAR(1),
    CONSTRAINT pKey_AU_UserId PRIMARY KEY (UserId)
);

-- Admin:UserType='A' Director='D' Manager:UserType='M' Cashier:UserType ='C'
-- UserActive = T/F

INSERT INTO AppUser VALUES('admin','admin','admin','A','admin@amftn.in','123456789','T');
INSERT INTO AppUser VALUES('director','director','director','D','admin@amftn.in','123456789','T');
INSERT INTO AppUser VALUES('manager','manager','manager','M','admin@amftn.in','123456789','T');
INSERT INTO AppUser VALUES('cashier','cashier','cashier','C','admin@amftn.in','123456789','T');


-- Version 2.0 (No Change)
CREATE TABLE Branch (
    BranchId INT,
    BranchName VARCHAR(25) UNIQUE,
    Address VARCHAR(40),
    BranchManager VARCHAR(20),
    CONSTRAINT pKey_B_BranchId PRIMARY KEY (BranchId),
    CONSTRAINT fKey_B_UserId FOREIGN KEY (BranchManager)
        REFERENCES AppUser (UserId)
); 

INSERT INTO Branch VALUES(1,'Nagamalai Pudukottai','Nagamalai Pudukottai','manager');

-- Version 2.0 (No Change)
CREATE TABLE BranchUser (
    BranchId INT,
    UserId VARCHAR(20)
);



-- Version 2.0 (Modified: CenterCode added as pKey)
CREATE TABLE Center (
    CenterCode CHAR(5),
	CenterId INT,
    CenterName VARCHAR(40) UNIQUE,
    BranchId INT,
    CONSTRAINT pKey_GC_CenterCode PRIMARY KEY (CenterCode),
    CONSTRAINT fKey_GC_BranchId FOREIGN KEY (BranchId) REFERENCES Branch (BranchId)
);

-- Version 2.0 (Modified: GroupCode added as pKey)
CREATE TABLE MemberGroup (
    GroupCode CHAR(7), 
	GroupId INT,
    GroupName VARCHAR(40) UNIQUE,
    CenterCode CHAR(5),
    CONSTRAINT pKey_MG_GroupCode PRIMARY KEY (GroupCode),
    CONSTRAINT fKey_MG_CenterId FOREIGN KEY (CenterCode) REFERENCES Center(CenterCode)
);

-- Version 2.0 (Modified: MemberCode added as pKey)
CREATE TABLE Member (
    MemberCode CHAR(9), 
	MemberId INT,
    GroupCode CHAR(7),
    MemberType INT,
    MemberName VARCHAR(50),
	Gender INT,
    DOB DATE,
	MaritalStatus INT,
	Religion INT,
	FName VARCHAR(50),
    HName VARCHAR(50),
	Occupation INT,
	OccupationType INT,
    AddressLine1 VARCHAR(40),
    AddressLine2 VARCHAR(40),
    AddressLine3 VARCHAR(40),
    AddressLine4 VARCHAR(40),
	Taluk VARCHAR(40),
	Panchayat VARCHAR(40),
    City VARCHAR(30),
    Pincode CHAR(6),
	NoOfYears INT,
	HouseType INT,
	PropertyOwnership INT,
	Phone CHAR(10),
    MemberAadharNumber CHAR(12) UNIQUE,
	PAN CHAR(10),
    RationCardNo VARCHAR(30),
    VoterIDNo VARCHAR(30),
	AccountNumber VARCHAR(20),
	IFSC CHAR(11),
    NomineeName VARCHAR(50),
    Relationship INT,
    NomineeAadharNumber CHAR(12),
    NomineeDOB DATE,
	BankCustomerId VARCHAR(20),
	CONSTRAINT pKey_M_MemberCode PRIMARY KEY(MemberCode),
    CONSTRAINT fKey_M_GroupCode FOREIGN KEY (GroupCode) REFERENCES MemberGroup(GroupCode)
);

-- Version 2.0 (LoanCode added)
CREATE TABLE Loan (
    LoanCode CHAR(10),
    MemberCode CHAR(9),
	LoanCycle INT,
    BranchId INT,
	LoanPurpose VARCHAR(40),
    LoanAmount INT,
    ProcessingFeeRate DECIMAL(4 , 2 ),
    ProcessingFee INT,
    InsuranceRate DECIMAL(4 , 2 ),
    Insurance INT,
    Tenure INT,
    InterestRate DECIMAL(5 , 2 ),
    EWI INT,
    LoanStatus CHAR(1),
    LoanDate DATE,
    LoanDisposalDate DATE,
    ApprovedBy VARCHAR(20),
	StatusRemarks VARCHAR(50),
    PreClosureDiscount INT,
    BadLoanDiscount INT,
    CONSTRAINT pKey_L_LoanCode PRIMARY KEY (LoanCode),
    CONSTRAINT fKey_L_MemberCode FOREIGN KEY (MemberCode)
        REFERENCES Member (MemberCode),
    CONSTRAINT fKey_L_BranchId FOREIGN KEY (BranchId)
        REFERENCES Branch (BranchId),
    CONSTRAINT fKey_L_ApprovedBy FOREIGN KEY (ApprovedBy)
        REFERENCES AppUser (UserId)
);
-- LoanStatus: P=Pending, A-Approved O-Ongoing, C-Closed, S- Pre-Closed, b- Bad loan initiated, B- Bad loan closed

CREATE TABLE CashReceipt (
    ReceiptId INT AUTO_INCREMENT,
    LoanCode CHAR(10),
    ReceiptType CHAR(1),
    ReceiptAmount INT,
    ReceiptDate DATE,
    Description VARCHAR(100),
    UserId VARCHAR(20),
	ActualReceiptDate DATE,
    CONSTRAINT pKey_CR_ReceiptId PRIMARY KEY (ReceiptId),
    CONSTRAINT fKey_CR_LoanCode FOREIGN KEY (LoanCode)
        REFERENCES Loan (LoanCode) ON UPDATE CASCADE,
    CONSTRAINT fKey_CR_UserId FOREIGN KEY (UserId)
        REFERENCES AppUser (UserId)
); 
-- ProcessingFee: ReceiptType='P'; EWI: ReceiptType='I'; Settlement: ReceiptType='S'  

-- Patch 26 Apr 2020
-- alter table cashreceipt drop FOREIGN KEY fKey_CR_LoanCode
-- alter table cashreceipt add constraint fKey_CR_LoanCode FOREIGN KEY (LoanCode) REFERENCES Loan (LoanCode) ON UPDATE CASCADE

-- GetUserType
-- Version 2.0 (No Change)
DELIMITER //
DROP FUNCTION IF EXISTS `GetUserType`//
CREATE FUNCTION GetUserType(pUserId VARCHAR(20), pPasswd VARCHAR(16)) RETURNS CHAR(1)
READS SQL DATA
BEGIN
	DECLARE vUserType CHAR(1);
	SELECT UserType	 INTO vUserType FROM AppUser WHERE LOWER(UserId) = LOWER(pUserId) AND Passwd = pPasswd AND UserActive = 'T';
    IF 	vUserType IS NULL THEN
		SET vUserType := 'I';
	END IF;
	RETURN vUserType;
END//
DELIMITER ;
SET GLOBAL log_bin_trust_function_creators = 1;
-- Test
SELECT GetUserType('admin','admin');

-- GetBranch
-- Version 2.0 (No Change)
DELIMITER //
DROP FUNCTION IF EXISTS `GetBranchName`//
CREATE FUNCTION GetBranchName(pBranchId INT) RETURNS VARCHAR(25)
READS SQL DATA
BEGIN
	DECLARE vBranchName VARCHAR(25);
	SELECT BranchName INTO vBranchName FROM Branch WHERE BranchId = pBranchId;
	RETURN vBranchName;
END//
DELIMITER ;

-- Test
SELECT GetBranchName(1); 


-- AddCenter
-- Version 2.0 (Modified: CenterCode instead of CenterId)
DELIMITER //
DROP PROCEDURE IF EXISTS `AddCenter`//
CREATE PROCEDURE AddCenter(OUT pCenterCode CHAR(5), pCenterName VARCHAR(40), pBranchId INT, OUT pStatusCode INT)
BEGIN
	DECLARE vCheck INT;
	DECLARE vCenterId INT;
	DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET vCheck=0;
	DECLARE CONTINUE HANDLER FOR 1062 SET vCheck=0;
	SET pStatusCode:=1;
	SET vCheck:=1;
	SELECT MAX(CenterId) INTO vCenterId FROM Center WHERE BranchId=pBranchId;
	IF vCenterId IS NULL THEN
		SET vCenterId := 1;
	ELSE
		SET vCenterId := vCenterId + 1;
	END IF;
	SET pCenterCode := CONCAT(LPAD(pBranchId,3,'0'),LPAD(vCenterId,2,'0'));
	INSERT INTO Center(CenterCode, CenterId, CenterName, BranchId) VALUES(pCenterCode, vCenterId, pCenterName, pBranchId);
	IF vCheck=0 THEN
		SELECT COUNT(*) INTO vCheck FROM Center WHERE CenterName=pCenterName;
		IF vCheck>0 THEN
			SET pStatusCode:=0;
            COMMIT;
		ELSE
			SET pStatusCode:=-1;
		END IF;
	END IF;
END;//
DELIMITER ;

-- GetAllCenters
-- Version 2.0 (Modified: CenterCode instead of CenterId)
DELIMITER //
DROP PROCEDURE IF EXISTS `GetAllCenters`//
CREATE PROCEDURE GetAllCenters(pBranchId INT)
BEGIN
	SELECT CenterCode, CenterId, CenterName FROM Center WHERE BranchId = pBranchId ORDER BY CenterCode;
END//
DELIMITER ;
-- Test
CALL GetAllCenters(1);

-- GetCenter
-- Version 2.0 (Modified: CenterCode instead of CenterId)
DELIMITER //
DROP PROCEDURE IF EXISTS `GetCenter`//
CREATE PROCEDURE GetCenter(pCenterCode CHAR(5))
BEGIN
	SELECT CenterCode, CenterId, CenterName FROM Center WHERE CenterCode = pCenterCode;
END//
DELIMITER ;

-- Test
CALL GetCenter('00101');

-- EditCenter
-- Version 2.0 (Modified: CenterCode instead of CenterId)
DELIMITER //
DROP PROCEDURE IF EXISTS `EditCenter`//
CREATE PROCEDURE EditCenter(pCenterCode CHAR(5), pCenterName VARCHAR(40), OUT pStatusCode INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION SET pStatusCode=0;
	UPDATE Center SET CenterName=pCenterName WHERE CenterCode = pCenterCode;
    COMMIT;
	SET pStatusCode:=1;
END;//
DELIMITER ;

-- GetAllCentersByPattern
-- Version 2.0 (Modified: CenterCode instead of CenterId)
DELIMITER // 
DROP PROCEDURE IF EXISTS `GetAllCentersByPattern`//
CREATE PROCEDURE GetAllCentersByPattern(pCenterNamePattern VARCHAR(40))
BEGIN
	SELECT CenterCode, CenterName FROM Center WHERE LOWER(CenterName) LIKE CONCAT(LOWER(pCenterNamePattern),'%') ORDER BY CenterName;
END//
DELIMITER ;

-- Test
CALL GetAllCentersByPattern('nag');


-- AddMemberGroup (20-04-2019)
-- Version 2.0 (Modified: CenterCode instead of CenterId, GroupCode instead of GroupId)
DELIMITER //
DROP PROCEDURE IF EXISTS `AddMemberGroup`//
CREATE PROCEDURE AddMemberGroup(OUT pGroupCode CHAR(7), pGroupName VARCHAR(40), pCenterCode CHAR(5), OUT pStatusCode INT)
BEGIN
	DECLARE vCheck INT;
	DECLARE vGroupId INT;
	DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET vCheck=0;
	SET pStatusCode:=1;
	SET vCheck:=1;
	
	SELECT MAX(GroupId) INTO vGroupId FROM MemberGroup WHERE CenterCode=pCenterCode;
	IF vGroupId IS NULL THEN
		SET vGroupId := 1;
	ELSE
		SET vGroupId := vGroupId + 1;
	END IF;
	SET pGroupCode := CONCAT(pCenterCode, LPAD(vGroupId,2,'0'));
	INSERT INTO MemberGroup(GroupCode, GroupId, GroupName, CenterCode) VALUES(pGroupCode, vGroupId, pGroupName, pCenterCode);
	IF vCheck=0 THEN
		SELECT COUNT(*) INTO vCheck FROM MemberGroup WHERE GroupName=pGroupName;
		IF vCheck>0 THEN
			SET pStatusCode:=0;
            COMMIT;
		ELSE
			SET pStatusCode:=-1;
		END IF;
	END IF;
END;//
DELIMITER ;

-- GetMemberGroup
-- Version 2.0 (Modified: CenterCode instead of CenterId, GroupCode instead of GroupId)
DELIMITER //
DROP PROCEDURE IF EXISTS `GetMemberGroup`//
CREATE PROCEDURE GetMemberGroup(pGroupCode CHAR(7))
BEGIN
    SELECT 
        MG.GroupId, 
        MG.GroupCode, 
        MG.GroupName, 
        MG.CenterCode, 
        GC.CenterName,
        M.MemberName AS LeaderName
    FROM MemberGroup MG 
    INNER JOIN Center GC ON MG.CenterCode = GC.CenterCode
    LEFT JOIN Member M ON MG.GroupCode = M.GroupCode AND M.MemberType = 1
    WHERE MG.GroupCode = pGroupCode;
END//
DELIMITER ;

-- Test
CALL GetMemberGroup('0010101');

-- GetAllMemberGroups
-- Version 2.0 (Modified: CenterCode instead of CenterId, GroupCode instead of GroupId)
DELIMITER //
DROP PROCEDURE IF EXISTS `GetAllMemberGroups`//
CREATE PROCEDURE GetAllMemberGroups(pBranchId INT)
BEGIN
	SELECT MG.GroupCode, MG.GroupId, MG.GroupName, MG.CenterCode, GC.CenterName, M.MemberName AS LeaderName 	
		FROM  MemberGroup MG INNER JOIN Center GC ON MG.CenterCode = GC.CenterCode  
        LEFT JOIN Member M ON MG.GroupCode = M.GroupCode AND M.MemberType = 1
        WHERE GC.BranchId = pBranchId;
END//
DELIMITER ;
-- Test
CALL GetAllMemberGroups(1);

--EditMemberGroup
--Version 2.0 (Modified: CenterCode instead of CenterId, GroupCode instead of GroupId)
DELIMITER //
DROP PROCEDURE IF EXISTS `EditMemberGroup`//
CREATE PROCEDURE EditMemberGroup(pGroupCode CHAR(7), pGroupName VARCHAR(40), pCenterCode CHAR(5), OUT pStatusCode INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION SET pStatusCode=0;
	UPDATE MemberGroup SET GroupName=pGroupName WHERE GroupCode = pGroupCode;
	SET pStatusCode:=1;
    COMMIT;
END;//
DELIMITER ;

-- GetAllMemberGroupsByPattern
-- Version 2.0 (Modified: GroupCode instead of GroupId)
DELIMITER //
DROP PROCEDURE IF EXISTS `GetAllMemberGroupsByPattern`//
CREATE PROCEDURE GetAllMemberGroupsByPattern(pGroupNamePattern VARCHAR(40))
BEGIN
	SELECT MG.GroupCode, MG.GroupName, GC.CenterName, IFNULL((SELECT MemberName FROM Member M WHERE M.GroupCode=MG.GroupCode AND M.MemberType=1),'NA') AS LeaderName FROM 
		MemberGroup MG INNER JOIN Center GC 
		ON MG.CenterCode = GC.CenterCode WHERE LOWER(GroupName) LIKE CONCAT(LOWER(pGroupNamePattern),'%') ORDER BY GroupName;
END//
DELIMITER ;
-- Test
CALL GetAllMemberGroupsByPattern('mah');


--AddMember 
--Version 2.0 (Modified: GroupCode instead of GroupId, MemberCode instead of MemberId)
DELIMITER //
DROP PROCEDURE IF EXISTS `AddMember`//
CREATE PROCEDURE AddMember(OUT pMemberCode CHAR(9), 
							pGroupCode CHAR(7), 
							pMemberType INT, 
							pMemberName VARCHAR(50),
							pGender INT,
							pDOB DATE,
							pMaritalStatus INT,
							pReligion INT,
							pFName VARCHAR(50), 
							pHName VARCHAR(50),
							pOccupation INT,
							pOccupationType INT,
							pAddressLine1 VARCHAR(40), 
							pAddressLine2 VARCHAR(40), 
							pAddressLine3 VARCHAR(40), 
							pAddressLine4 VARCHAR(40), 
							pTaluk VARCHAR(40),
							pPanchayat VARCHAR(40),
							pCity VARCHAR(30), 
							pPincode CHAR(6), 
							pNoOfYears INT,
							pHouseType INT,
							pPhone CHAR(10), 
							pMemberAadharNumber CHAR(12), 
							pPAN CHAR(10), 
							pRationCardNo VARCHAR(30), 
							pVoterIDNo VARCHAR(30),
							pAccountNumber VARCHAR(20),
							pIFSC CHAR(11),
							pBankCustomerId VARCHAR(20),
							pNomineeName VARCHAR(50), 
							pRelationship INT, 
							pNomineeAadharNumber CHAR(12), 
							pNomineeDOB DATE, 
							OUT pStatusCode INT)
AddMember: BEGIN
	DECLARE vCheck INT;
	DECLARE vMemberId INT;
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET vCheck=0;
	SET pStatusCode := 1;
	IF pMemberType=1 THEN
		SELECT COUNT(*) INTO vCheck FROM Member WHERE MemberType=1 AND GroupCode=pGroupCode;
		IF vCheck>0 THEN
			SET pStatusCode := -2;
			LEAVE AddMember;
		END IF;
	END IF;
	SET vCheck := 1;
	SELECT MAX(MemberId) INTO vMemberId FROM Member WHERE GroupCode = pGroupCode;
	IF vMemberId IS NULL THEN
		SET vMemberId := 1;
	ELSE
		SET vMemberId := vMemberId + 1;
	END IF;
	SET pMemberCode := CONCAT(pGroupCode, LPAD(vMemberId,2,'0'));
	INSERT INTO Member(MemberCode, MemberId, GroupCode, MemberType, MemberName,Gender, DOB, MaritalStatus, Religion, 
					   FName, HName, Occupation, OccupationType, AddressLine1, AddressLine2, AddressLine3, AddressLine4,
					   Taluk, Panchayat,
					   City, Pincode, NoOfYears, HouseType, Phone, MemberAadharNumber, PAN, RationCardNo, VoterIDNo, 
					   AccountNumber, IFSC,BankCustomerId, NomineeName, Relationship, NomineeAadharNumber, NomineeDOB) 
					   VALUES
					   (pMemberCode, vMemberId, pGroupCode, pMemberType, pMemberName,pGender, pDOB, pMaritalStatus, pReligion, 
					   pFName, pHName, pOccupation, pOccupationType, pAddressLine1, pAddressLine2, pAddressLine3, 
					   pAddressLine4, pTaluk, pPanchayat, pCity, pPincode, pNoOfYears, pHouseType, pPhone, 
					   pMemberAadharNumber, pPAN,pRationCardNo, pVoterIDNo, pAccountNumber, pIFSC, pBankCustomerId, 
					   pNomineeName, pRelationship, pNomineeAadharNumber, pNomineeDOB);
	IF vCheck=0 THEN
		SELECT COUNT(*) INTO vCheck FROM Member WHERE MemberAadharNumber = pMemberAadharNumber;
        COMMIT;
		IF vCheck>0 THEN
			SET pStatusCode := -1;
		ELSE
			SET pStatusCode := -3;
		END IF;
	END IF;
END//
DELIMITER ;


-- GetAllMembers
-- Version 2.0 (Modified: GroupCode instead of GroupId, MemberCode instead of MemberId)
DELIMITER //
DROP PROCEDURE IF EXISTS `GetAllMembers`//
CREATE PROCEDURE GetAllMembers(pGroupCode CHAR(7))
BEGIN
	SELECT M.MemberCode, M.MemberId, M.GroupCode, MG.GroupName, GC.CenterName, GC.CenterCode, GC.BranchId,  
		IFNULL((SELECT MemberName FROM Member InnerM WHERE InnerM.GroupCode=MG.GroupCode AND InnerM.MemberType=1),'NA') AS LeaderName,
		IFNULL((SELECT MAX(LoanCode) FROM Loan L WHERE L.MemberCode = M.MemberCode),'0') AS CurrentLoanCode,
		M.MemberName, M.MemberType, M.Gender, M.DOB, M.MaritalStatus, M.Religion, M.FName, M.HName, M.Occupation, M.OccupationType, 
		M.AddressLine1, M.AddressLine2, M.AddressLine3, M.AddressLine4, M.Taluk, M.Panchayat, M.City, M.Pincode, 
		M.NoOfYears, M.HouseType, M.PropertyOwnership, M.Phone, 
		M.MemberAadharNumber, M.PAN, M.RationCardNo, M.VoterIDNo, M.AccountNumber, M.IFSC, M.BankCustomerId,  
		M.NomineeName, M.Relationship, M.NomineeAadharNumber, M.NomineeDOB
		FROM  Member M INNER JOIN MemberGroup MG ON M.GroupCode=MG.GroupCode INNER JOIN Center GC ON MG.CenterCode = GC.CenterCode  
	WHERE M.GroupCode = pGroupCode;
END//
DELIMITER ;
-- Test
CALL GetAllMembers('0010101')


-- GetMember
-- Version 2.0 (Modified: GroupCode instead of GroupId, MemberCode instead of MemberId)
DELIMITER //
DROP PROCEDURE IF EXISTS `GetMember`//
CREATE PROCEDURE GetMember(pMemberCode CHAR(9))
BEGIN
	SELECT M.MemberCode, M.MemberId, M.GroupCode, MG.GroupName, GC.CenterName, GC.CenterCode, GC.BranchId,  
		IFNULL((SELECT MemberName FROM Member InnerM WHERE InnerM.GroupCode=MG.GroupCode AND InnerM.MemberType=1),'NA') AS LeaderName,
		IFNULL((SELECT MAX(LoanCode) FROM Loan L WHERE L.MemberCode = M.MemberCode),'0') AS CurrentLoanCode,
		M.MemberName, M.MemberType, M.Gender, M.DOB, M.MaritalStatus, M.Religion, M.FName, M.HName, M.Occupation, M.OccupationType, 
		M.AddressLine1, M.AddressLine2, M.AddressLine3, M.AddressLine4, M.Taluk, M.Panchayat, M.City, M.Pincode, 
		M.NoOfYears, M.HouseType, M.PropertyOwnership, M.Phone, 
		M.MemberAadharNumber, M.PAN, M.RationCardNo, M.VoterIDNo, M.AccountNumber, M.IFSC, M.BankCustomerId,  
		M.NomineeName, M.Relationship, M.NomineeAadharNumber, M.NomineeDOB
		FROM  Member M INNER JOIN MemberGroup MG ON M.GroupCode=MG.GroupCode INNER JOIN Center GC ON MG.CenterCode = GC.CenterCode  
		WHERE M.MemberCode = pMemberCode;
END//
DELIMITER ;
-- Test
CALL GetMember(1)


-- EditMember
-- Version 2.0 (Modified: GroupCode instead of GroupId, MemberCode instead of MemberId)
DELIMITER //
DROP PROCEDURE IF EXISTS `EditMember`//
CREATE PROCEDURE EditMember(pMemberCode CHAR(9), 
							pGroupCode CHAR(7), 
							pMemberType INT, 
							pMemberName VARCHAR(50),
							pGender INT,
							pDOB DATE,
							pMaritalStatus INT,
							pReligion INT,
							pFName VARCHAR(50), 
							pHName VARCHAR(50),
							pOccupation INT,
							pOccupationType INT,							
							pAddressLine1 VARCHAR(40), 
							pAddressLine2 VARCHAR(40), 
							pAddressLine3 VARCHAR(40), 
							pAddressLine4 VARCHAR(40), 
							pTaluk VARCHAR(40),
							pPanchayat VARCHAR(40),
							pCity VARCHAR(30), 
							pPincode CHAR(6), 
							pNoOfYears INT,
							pHouseType INT,
							pPhone CHAR(10), 
							pMemberAadharNumber CHAR(12), 
							pPAN CHAR(10), 
							pRationCardNo VARCHAR(30), 
							pVoterIDNo VARCHAR(30),
							pAccountNumber VARCHAR(20),
							pIFSC CHAR(11),
							pBankCustomerId VARCHAR(20),
							pNomineeName VARCHAR(50), 
							pRelationship INT, 
							pNomineeAadharNumber CHAR(12), 
							pNomineeDOB DATE, 
							OUT pStatusCode INT)
EditMember:BEGIN
	DECLARE vCheck INT;
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET vCheck=0;
	IF pMemberType=1 THEN
		SELECT COUNT(*) INTO vCheck FROM Member WHERE MemberType=1 AND GroupCode=pGroupCode AND MemberId<>pMemberId;
		IF vCheck>0 THEN
			SET pStatusCode := -2;
			LEAVE EditMember;
		END IF;
	END IF;
	SET vCheck := 1;
	SET pStatusCode := 1;
	UPDATE Member SET MemberType=pMemberType, MemberName=pMemberName, Gender=pGender, DOB=pDOB,
						MaritalStatus=pMaritalStatus, Religion=pReligion, FName=pFName, HName=pHName,
						Occupation=pOccupation, OccupationType = pOccupationType,
						AddressLine1=pAddressLine1, AddressLine2=pAddressLine2, AddressLine3=pAddressLine3, 
						AddressLine4=pAddressLine4, Taluk=pTaluk, Panchayat=pPanchayat,
						City=pCity, Pincode=pPincode, NoOfYears=pNoOfYears, HouseType=pHouseType,
						Phone=pPhone, MemberAadharNumber=pMemberAadharNumber, PAN=pPAN, RationCardNo=pRationCardNo,
						VoterIDNo=pVoterIDNo, AccountNumber=pAccountNumber, IFSC = pIFSC, BankCustomerId = pBankCustomerId, 
						NomineeName=pNomineeName, Relationship=pRelationship,
						NomineeAadharNumber=pNomineeAadharNumber, NomineeDOB=pNomineeDOB 
		WHERE MemberCode=pMemberCode;
	IF vCheck=0 THEN
		SELECT COUNT(*) INTO vCheck FROM Member WHERE MemberAadharNumber = pMemberAadharNumber AND MemberCode<>pMemberCode;
        COMMIT;
		IF vCheck>0 THEN
			SET pStatusCode := -1;
		ELSE
			SET pStatusCode := -3;
		END IF;
	END IF;
END;//
DELIMITER ;

-- GetMemberByAadhar
-- Version 2.0 (Modified: MemberCode instead of MemerId
DELIMITER //
DROP PROCEDURE IF EXISTS `GetMemberByAadhar`//
CREATE PROCEDURE GetMemberByAadhar(pSearchText VARCHAR(20))
BEGIN
	SELECT MemberCode, MemberName FROM Member WHERE MemberAadharNumber=pSearchText;
END//
DELIMITER ;

-- GetMemberByPhone 
-- Version 2.0 (Modified: MemberCode instead of MemerId
DELIMITER //
DROP PROCEDURE IF EXISTS `GetMemberByPhone`//
CREATE PROCEDURE GetMemberByPhone(pSearchText VARCHAR(20))
BEGIN	
	SELECT MemberCode, MemberName FROM Member WHERE Phone=pSearchText;
END//
DELIMITER ;

-- GetMemberByPhone
-- Version 2.0 (Modified: MemberCode instead of MemerId)
DELIMITER //
DROP PROCEDURE IF EXISTS `GetMemberByName`//
CREATE PROCEDURE GetMemberByName(pSearchText VARCHAR(20))
BEGIN	
	SELECT MemberCode, MemberName FROM Member WHERE LOWER(MemberName) LIKE CONCAT('%', LOWER(pSearchText),'%');
END//
DELIMITER ;

-- CheckMember
-- Version 2.0 (Modified: MemberCode instead of MemerId)
DELIMITER //
DROP FUNCTION IF EXISTS `CheckMember`//
CREATE FUNCTION CheckMember(pMemberCode CHAR(9)) RETURNS CHAR(50)
READS SQL DATA
BEGIN
	DECLARE vCheck INT;
	DECLARE vMemberName CHAR(50);
	SELECT COUNT(*) INTO vCheck FROM Loan WHERE MemberCode = pMemberCode AND LoanStatus<>'C';
	IF vCheck>0 THEN
		SET vMemberName := 'Loan exists';	
	ELSE
		SELECT MemberName INTO vMemberName FROM Member WHERE MemberCode = pMemberCode;
	END IF;
	IF vMemberName IS NULL THEN
		SET vMemberName := 'Not found';
	END IF;
	RETURN vMemberName;
END//
DELIMITER ;
-- Test
SELECT CheckMember('001010101');


-- CheckGroup 
-- Version 2.0 (Modified: GroupCode instead of GroupId)
DELIMITER //
DROP FUNCTION IF EXISTS `CheckGroup`//
CREATE FUNCTION CheckGroup(pGroupCode CHAR(7)) RETURNS CHAR(50)
READS SQL DATA
BEGIN
	DECLARE vCheck INT;
	DECLARE vResponse CHAR(50);
	SELECT COUNT(*) INTO vCheck FROM MemberGroup WHERE GroupCode = pGroupCode;
	IF vCheck=0 THEN
		RETURN 'Not found';
	END IF;
	SELECT COUNT(*) INTO vCheck FROM Loan L INNER JOIN Member M ON L.MemberCode = M.MemberCode 
		INNER JOIN MemberGroup MG ON M.GroupCode=MG.GroupCode WHERE MG.GroupCode=pGroupCode AND L.LoanStatus <> 'C';
	IF vCheck>0 THEN
		SET vResponse := 'Loan exists';	
	ELSE
		SET vResponse := 'Success';	
	END IF;
	RETURN vResponse;
END//
DELIMITER ;
-- Test
SELECT CheckGroup(1);


-- GetGroupCode
-- Version 2.0 (Modified: GroupCode instead of GroupId)
DELIMITER //
DROP FUNCTION IF EXISTS `GetGroupCode`//
CREATE FUNCTION GetGroupCode(pMemberCode CHAR(9)) RETURNS CHAR(7)
READS SQL DATA
BEGIN
	DECLARE vGroupCode CHAR(7);
	SELECT GroupCode INTO vGroupCode FROM Member WHERE MemberCode = pMemberCode;
	RETURN vGroupCode;
END//
DELIMITER ;
-- Test
SELECT GetGroupCode('001010101');

-- AddLoan
-- Version 3.0 (Modified: LoanCode format changed)
DELIMITER //
DROP PROCEDURE IF EXISTS `AddLoan`//
CREATE PROCEDURE AddLoan(OUT pLoanCode CHAR(10), pMemberCode CHAR(9), pBranchId INT, pLoanPurpose VARCHAR(40), 
						pLoanAmount INT, pLoanDate DATE, pLoanDisposalDate DATE, pProcessingFeeRate INT, pProcessingFee INT, 
						pInsuranceRate INT, pInsurance INT, pTenure INT, pInterestRate INT, pEWI INT, OUT pStatus INT)
AddLoan:BEGIN
	DECLARE vCheck VARCHAR(50);
	DECLARE vLoanCycle INT;
	DECLARE vLoanCode CHAR(10);
	DECLARE vNewLoanCode INT;
	DECLARE EXIT HANDLER FOR SQLEXCEPTION SET pStatus=-1;
	SET vCheck:=CheckMember(pMemberCode);
	IF vCheck='Not found' || vCheck='Loan exists' THEN
		SET pStatus:=0;
		SET pLoanCode:='0';
		Leave AddLoan;
	ELSE
		SET pStatus:=1;
	END IF;
	SELECT MAX(LoanCode) INTO vLoanCode FROM LOAN;
	IF vLoanCode IS NULL THEN
		SET vNewLoanCode := 1;
	ELSE
		SET vNewLoanCode = CAST(SUBSTR(vLoanCode,4,6) AS UNSIGNED) + 1;	
	END IF;
	SET pLoanCode := CONCAT('001A',LPAD(vNewLoanCode,6,'0'));
	SELECT COUNT(*) INTO vLoanCycle FROM Loan WHERE MemberCode=pMemberCode;
	SET vLoanCycle := vLoanCycle + 1;
	
	INSERT INTO Loan (LoanCode, MemberCode, LoanCycle, BranchId, LoanPurpose, LoanAmount, ProcessingFeeRate, ProcessingFee, InsuranceRate, 
					Insurance, Tenure, InterestRate, EWI, LoanStatus, LoanDate, LoanDisposalDate, ApprovedBy, StatusRemarks,PreClosureDiscount, BadLoanDiscount) 
					VALUES (pLoanCode, pMemberCode, vLoanCycle, pBranchId, pLoanPurpose, pLoanAmount, pProcessingFeeRate, pProcessingFee, 
					pInsuranceRate, pInsurance, pTenure, pInterestRate, pEWI, 'P', pLoanDate, pLoanDisposalDate, NULL, NULL,0,0);
	COMMIT;
END;//
DELIMITER ;

--AddGroupLoan
--Version 3.0 (Modified: LoanCode format changed)
DELIMITER //
DROP PROCEDURE IF EXISTS `AddGroupLoan`//
CREATE PROCEDURE AddGroupLoan(pGroupCode VARCHAR(7), pBranchId INT, pLoanPurpose VARCHAR(40), pLoanAmount INT, pLoanDate DATE, 
							pLoanDisposalDate DATE, pProcessingFeeRate INT, pProcessingFee INT, pInsuranceRate INT, pInsurance INT, 
							pTenure INT, pInterestRate INT, pEWI INT, OUT pStatus INT)
AddGroupLoan:BEGIN
	DECLARE vCheck VARCHAR(50);
	DECLARE vLoanCode CHAR(10);
	DECLARE vNewLoanCode INT;
	DECLARE vMemberCode CHAR(9);
	DECLARE vCompleted INT;
	DECLARE vLoanCycle INT;
	DECLARE cMember CURSOR FOR SELECT MemberCode FROM Member WHERE GroupCode = pGroupCode;
	DECLARE EXIT HANDLER FOR SQLEXCEPTION SET pStatus=-1;
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET vCompleted=0;
	SET vCheck:=CheckGroup(pGroupCode);
	IF vCheck='Not found' || vCheck='Loan exists' THEN
		SET pStatus:=0;
		Leave AddGroupLoan;
	ELSE
		SET pStatus:=1;
	END IF;
	
	SELECT MAX(LoanCode) INTO vLoanCode FROM LOAN;
	IF vLoanCode IS NULL THEN
		SET vNewLoanCode := 0;
	ELSE
		SET vNewLoanCode = CAST(SUBSTR(vLoanCode,5,5) AS UNSIGNED);	
	END IF;
	
	SET vCompleted:=1;
	OPEN cMember;
	CursorLoop: LOOP
		FETCH cMember INTO vMemberCode;
		IF vCompleted=0 THEN
			LEAVE CursorLoop;
		END IF;
		SET vNewLoanCode := vNewLoanCode + 1; 
		SET vLoanCode := CONCAT('001A',LPAD(vNewLoanCode,6,'0'));
		SELECT COUNT(*) INTO vLoanCycle FROM Loan WHERE MemberCode=vMemberCode;
		SET vLoanCycle := vLoanCycle + 1;
		
		INSERT INTO Loan (LoanCode, MemberCode, LoanCycle, BranchId, LoanPurpose, LoanAmount, ProcessingFeeRate, ProcessingFee, InsuranceRate, 
					Insurance, Tenure, InterestRate, EWI, LoanStatus, LoanDate, LoanDisposalDate, ApprovedBy, StatusRemarks,PreClosureDiscount, BadLoanDiscount) 
					VALUES (vLoanCode, vMemberCode, vLoanCycle, pBranchId, pLoanPurpose, pLoanAmount, pProcessingFeeRate, pProcessingFee, 
					pInsuranceRate, pInsurance, pTenure, pInterestRate, pEWI, 'P', pLoanDate, pLoanDisposalDate, NULL, NULL, 0, 0);
	END LOOP;
END;//
DELIMITER ;

-- GetAllLoans 
-- Version 2.0 (Modified: GroupCode instead of GroupId)
DELIMITER // 
DROP PROCEDURE IF EXISTS `GetAllLoans`//
CREATE PROCEDURE GetAllLoans(pBranchId INT, pGroupCode CHAR(7))
BEGIN
	SELECT L.LoanCode, L.MemberCode, M.MemberName, L.BranchId, L.LoanPurpose, L.LoanAmount, L.ProcessingFeeRate, L.ProcessingFee, 
		   L.InsuranceRate, L.Insurance, L.Tenure, L.InterestRate, L.EWI, L.LoanStatus, L.StatusRemarks, L.LoanCycle
		   FROM Loan L INNER JOIN Member M ON L.MemberCode = M.MemberCode WHERE BranchId=pBranchId AND M.GroupCode=pGroupCode 
		   AND L.LoanCycle=(SELECT MAX(LoanCycle) FROM Loan L1 WHERE L1.MemberCode=L.MemberCode) ;
END//
DELIMITER ;
-- Test
CALL GetAllLoans(1,1)


-- GetAllMemberLoans (Used for loan Transfer report)
-- Version 2.0 (Modified: GroupCode instead of GroupId)
DELIMITER // 
DROP PROCEDURE IF EXISTS `GetAllMemberLoans`//
CREATE PROCEDURE GetAllMemberLoans(pBranchId INT, pGroupCode CHAR(7))
BEGIN
	SELECT L.LoanCode, L.MemberCode, M.MemberName, M.AccountNumber, M.IFSC, L.BranchId, L.LoanPurpose, L.LoanAmount, L.ProcessingFeeRate, L.ProcessingFee, 
		   L.InsuranceRate, L.Insurance, L.Tenure, L.InterestRate, L.EWI, L.LoanStatus, L.StatusRemarks, L.LoanCycle
		   FROM Loan L INNER JOIN Member M ON L.MemberCode = M.MemberCode WHERE BranchId=pBranchId AND M.GroupCode=pGroupCode 
		   AND L.LoanCycle=(SELECT MAX(LoanCycle) FROM Loan L1 WHERE L1.MemberCode=L.MemberCode);
END//
DELIMITER ;
-- Test
CALL GetAllMemberLoans(1,1)

-- GetGlobalMemberLoans (Used for export)
-- Version 2.0 (Modified: GroupCode instead of GroupId)
DELIMITER // 
DROP PROCEDURE IF EXISTS `GetGlobalMemberLoans`//
CREATE PROCEDURE GetGlobalMemberLoans(pBranchId INT)
BEGIN
	SELECT L.LoanCode, L.MemberCode, M.MemberName, M.AccountNumber, M.IFSC, L.BranchId, L.LoanPurpose, L.LoanAmount, L.ProcessingFeeRate, L.LoanDate, 
		   L.ProcessingFee, L.InsuranceRate, L.Insurance, L.Tenure, L.InterestRate, L.EWI, L.LoanStatus, L.StatusRemarks, L.LoanCycle,
		   (SELECT MAX(ReceiptDate) FROM CashReceipt WHERE LoanCode = L.LoanCode AND ReceiptType='I') AS LastPaymentDate
		   FROM Loan L INNER JOIN Member M ON L.MemberCode = M.MemberCode WHERE BranchId=pBranchId AND 
		   L.LoanCycle=(SELECT MAX(LoanCycle) FROM Loan L1 WHERE L1.MemberCode=L.MemberCode);
END//
DELIMITER ;
-- Test
CALL GetGlobalMemberLoans(1)

-- GetLoan
-- Version 2.0 (Modified: GroupCode instead of GroupId)
DELIMITER //
DROP PROCEDURE IF EXISTS `GetLoan`//
CREATE PROCEDURE GetLoan(pLoanCode CHAR(10))
BEGIN
	SELECT L.LoanCode, L.MemberCode, M.MemberName, L.BranchId, L.LoanPurpose, L.LoanAmount, L.ProcessingFeeRate, L.ProcessingFee, 
		   L.InsuranceRate, L.Insurance, L.Tenure, L.InterestRate, L.EWI, L.LoanStatus, L.StatusRemarks, L.LoanDate, L.LoanDisposalDate,
		   L.LoanCycle FROM Loan L INNER JOIN Member M ON L.MemberCode = M.MemberCode WHERE LoanCode=pLoanCode;
END//
DELIMITER ;
-- Test
CALL GetLoan(1)


-- EditLoan
-- Version 2.0 (Modified: GroupCode instead of GroupId)
DELIMITER //
DROP PROCEDURE IF EXISTS `EditLoan`//
CREATE PROCEDURE EditLoan(pLoanCode CHAR(10), pMemberCode CHAR(9), pBranchId INT, pLoanPurpose VARCHAR(40), pLoanAmount INT,pLoanDate DATE, 
						pLoanDisposalDate DATE, pProcessingFeeRate INT, pProcessingFee INT, pInsuranceRate INT, pInsurance INT, 
						pTenure INT, pInterestRate INT, pEWI INT, OUT pStatusCode INT)
BEGIN
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET pStatusCode=0;
	SET pStatusCode := 1;
	UPDATE Loan SET LoanPurpose=pLoanPurpose, LoanAmount=pLoanAmount,
						ProcessingFeeRate=pProcessingFeeRate, ProcessingFee=pProcessingFee,
						InsuranceRate=pInsuranceRate, Insurance=pInsurance, Tenure=pTenure, 
						InterestRate=pInterestRate, EWI=pEwi, LoanStatus='P', LoanDate=pLoanDate, LoanDisposalDate = pLoanDisposalDate 
						WHERE LoanCode = pLoanCode;
END;//
DELIMITER ;

-- GetAllPendingLoans 
-- Version 2.0 (Modified: GroupCode instead of GroupId)
DELIMITER //
DROP PROCEDURE IF EXISTS `GetAllPendingLoans`//
CREATE PROCEDURE GetAllPendingLoans(pBranchId INT)
BEGIN
	SELECT L.LoanCode, L.MemberCode, M.MemberName, L.BranchId, L.LoanPurpose, L.LoanAmount, L.ProcessingFeeRate, L.ProcessingFee, 
		   L.InsuranceRate, L.Insurance, L.Tenure, L.InterestRate, L.EWI, L.LoanStatus, L.StatusRemarks
		   FROM Loan L INNER JOIN Member M ON L.MemberCode = M.MemberCode WHERE BranchId=pBranchId AND LoanStatus='P';
END//
DELIMITER ;
-- Test
CALL GetAllPendingLoans(1)



-- ApproveLoan
-- Version 2.0 (Modified: LoanCode instead of LoanId)
DELIMITER //
DROP PROCEDURE IF EXISTS `ApproveLoan`//
CREATE PROCEDURE ApproveLoan(pLoanCode CHAR(10))
BEGIN
	UPDATE Loan SET LoanStatus='A' WHERE LoanCode=pLoanCode;
END//
DELIMITER ;

-- UpdateLoanStatus
-- Version 2.0 (Modified: LoanCode instead of LoanId)
DELIMITER //
DROP PROCEDURE IF EXISTS `UpdateLoanStatus`//
CREATE PROCEDURE UpdateLoanStatus(pLoanCode CHAR(10), pLoanStatus CHAR(1), pStatusRemarks VARCHAR(50), pApprovedBy VARCHAR(20))
BEGIN
	UPDATE Loan SET LoanStatus=pLoanStatus, StatusRemarks=pStatusRemarks, ApprovedBy=pApprovedBy WHERE LoanCode=pLoanCode;
END//
DELIMITER ;

-- GetLoanStatus
-- Version 2.0 (Modified: LoanCode instead of LoanId)
DELIMITER //
DROP PROCEDURE IF EXISTS `GetLoanStatus`//
CREATE PROCEDURE GetLoanStatus(pLoanCode CHAR(10), OUT pLoanStatus VARCHAR(1), OUT pMemberCode CHAR(9), OUT pMemberName VARCHAR(50)
							, OUT pProcessingFee INT, OUT pInsurance INT, OUT pEwi INT, OUT pNoOfInstalments INT
							, OUT pFromDate DATE, OUT pToDate DATE, OUT pTotalPendingInstalments INT)
GetLoanStatus:BEGIN
	DECLARE vTenure INT;
	DECLARE vLoanDisposalDate DATE;
	DECLARE vWeeksCompleted INT;
	DECLARE vWeeksPaid INT;
	DECLARE vAmountPaid INT;
	SET pLoanStatus := 'N';
	SET pNoOfInstalments := 0;
	SET pFromDate := SYSDATE();
	SET pToDate := SYSDATE();
	SELECT MemberCode, ProcessingFee, Insurance, Tenure, LoanDisposalDate, EWI, LoanStatus 
			INTO pMemberCode, pProcessingFee, pInsurance,  vTenure, vLoanDisposalDate, pEwi, pLoanStatus FROM Loan WHERE LoanCode = pLoanCode;
	IF pMemberCode IS NULL THEN
		SET pLoanStatus:='I';
		LEAVE GetLoanStatus;
	END IF;
	SELECT MemberName INTO pMemberName FROM Member WHERE MemberCode = pMemberCode;
	IF pLoanStatus = 'O' THEN
		SET vWeeksCompleted := FLOOR(DATEDIFF(SYSDATE(),vLoanDisposalDate)/7);
		IF vWeeksCompleted > vTenure THEN
			SET vWeeksCompleted := vTenure;
		END IF;
		SELECT SUM(ReceiptAmount) INTO vAmountPaid FROM CashReceipt WHERE LoanCode = pLoanCode AND ReceiptType='I';
		IF vAmountPaid IS NULL THEN
			SET vAmountPaid := 0;
		END IF;
		SET vWeeksPaid := vAmountPaid/pEwi;
		SET pNoOfInstalments := vWeeksCompleted - vWeeksPaid;
        SET pTotalPendingInstalments := vTenure - vWeeksPaid;
		IF pNoOfInstalments >= 1 THEN
			SET pFromDate := DATE_ADD(vLoanDisposalDate, INTERVAL (vWeeksPaid + 1)*7 DAY);
			SET pToDate := DATE_ADD(vLoanDisposalDate, INTERVAL (vWeeksPaid + pNoOfInstalments)*7 DAY);
		END IF;
	ELSE
		SET pEwi := 0;
	END IF;
END//
DELIMITER ;

--GeneratePFReceipt
--Version 2.0 (Modified: LoanCode instead of LoanId)
DELIMITER //
DROP PROCEDURE IF EXISTS `GeneratePFReceipt`//
CREATE PROCEDURE GeneratePFReceipt(pLoanCode CHAR(10), pActualReceiptDate DATE, pUserId VARCHAR(20), OUT pReceiptId INT)
BEGIN
	DECLARE vAmount INT;
	SELECT ProcessingFee + Insurance INTO vAmount FROM Loan WHERE LoanCode = pLoanCode;
	SAVEPOINT Trans;
	INSERT INTO CashReceipt(LoanCode, ReceiptType, ReceiptAmount, ReceiptDate, Description, ActualReceiptDate, UserId) 
		VALUES(pLoanCode, 'P', vAmount, SYSDATE(), 'Processing fee', pActualReceiptDate, pUserId);
	UPDATE Loan SET LoanStatus='O' WHERE LoanCode = pLoanCode;
	SET pReceiptId:= LAST_INSERT_ID();
	COMMIT;
END//
DELIMITER ;

-- GenerateInstalmentReceipt
-- Version 2.0 (Modified: LoanCode instead of LoanId)
DELIMITER //
DROP PROCEDURE IF EXISTS `GenerateInstalmentReceipt`//
CREATE PROCEDURE GenerateInstalmentReceipt(pLoanCode VARCHAR(10), pNoOfInstalments INT, pActualReceiptDate DATE, pUserId VARCHAR(20), OUT pReceiptId INT, OUT pNextDueDate DATE)
BEGIN
	DECLARE vAmount INT;
	DECLARE vDescription VARCHAR(50);
	DECLARE vTenure INT;
	DECLARE vLoanDisposalDate DATE;
	DECLARE vEWI INT;
	DECLARE vWeeksCompleted INT;
	DECLARE vWeeksPaid INT;
	DECLARE vAmountPaid INT;
	SELECT EWI INTO vAmount FROM Loan WHERE LoanCode = pLoanCode;
	SELECT Tenure, LoanDisposalDate, EWI INTO vTenure, vLoanDisposalDate, vEWI FROM Loan WHERE LoanCode = pLoanCode;
	SET vAmount := vEWI * pNoOfInstalments;
	SET pNextDueDate := NULL;
	SELECT SUM(ReceiptAmount) INTO vAmountPaid FROM CashReceipt WHERE LoanCode = pLoanCode AND ReceiptType='I';
	IF vAmountPaid IS NULL THEN
		SET vAmountPaid := 0;
	END IF;
	SET vWeeksPaid := vAmountPaid/vEWI;
	IF pNoOfInstalments = 1 THEN
		SET vDescription := CONCAT('Due:', 
									CAST(vWeeksPaid+1 AS CHAR)
									, '/'
									, CAST(vTenure AS CHAR), 
									' (' 
									, DATE_FORMAT(DATE_ADD(vLoanDisposalDate, INTERVAL (vWeeksPaid + 1)*7 DAY), '%d-%m-%Y')
									, ')');
	ELSE
		SET vDescription := CONCAT('Due:'
								, CAST(vWeeksPaid+1 AS CHAR)
								, ' to '
								, CAST(vWeeksPaid+pNoOfInstalments AS CHAR)
								, '/'
								, CAST(vTenure AS CHAR)
								, '('
								, DATE_FORMAT(DATE_ADD(vLoanDisposalDate, INTERVAL (vWeeksPaid + 1)*7 DAY),'%d-%m-%Y')
								, ' to '
								, DATE_FORMAT(DATE_ADD(vLoanDisposalDate, INTERVAL (vWeeksPaid + pNoOfInstalments)*7 DAY),'%d-%m-%Y')
								, ')');
	END IF;
	SAVEPOINT Trans;
	INSERT INTO CashReceipt(LoanCode, ReceiptType, ReceiptAmount, ReceiptDate, Description, ActualReceiptDate, UserId)
		VALUES(pLoanCode, 'I', vAmount, SYSDATE(), vDescription, pActualReceiptDate, pUserId);
	IF vWeeksPaid + pNoOfInstalments = vTenure THEN
		UPDATE Loan SET LoanStatus='C' WHERE LoanCode = pLoanCode;
	ELSE
		SET pNextDueDate := DATE_ADD(vLoanDisposalDate, INTERVAL (vWeeksPaid + pNoOfInstalments + 1)*7 DAY);
		IF pNextDueDate < SYSDATE() THEN
			SET pNextDueDate := SYSDATE();
		END IF;
	END IF;
    SET pReceiptId:= LAST_INSERT_ID();
	COMMIT;
END//
DELIMITER ;

-- GetEWIDue
-- Version 2.0
DELIMITER //
DROP PROCEDURE IF EXISTS `GetEWIDue`//
CREATE PROCEDURE GetEWIDue(pBranchId INT) 
BEGIN
	DECLARE vLoanCode CHAR(10);
	DECLARE vBranchId INT;
	DECLARE vMemberCode CHAR(9);
	DECLARE vMemberName VARCHAR(50);
	DECLARE vPhone VARCHAR(10);
	DECLARE vLoanAmount INT;
	DECLARE vTenure INT;
	DECLARE vEwi INT;
	DECLARE vLoanDisposalDate DATE;
	DECLARE vWeeksCompleted INT;
	DECLARE vWeeksPaid INT;
	DECLARE vAmountPaid INT;
	DECLARE vNoOfInstalments INT;
    DECLARE vPendingAmount INT;
	DECLARE vDueDate DATE;
	DECLARE vCompleted INT;
	DECLARE EWIDueCursor CURSOR FOR SELECT L.LoanCode, L.BranchId, L.MemberCode, M.MemberName, M.Phone, L.LoanAmount, L.Tenure, L.EWI, L.LoanDisposalDate FROM Loan L INNER JOIN Member M ON L.MemberCode = M.MemberCode WHERE (L.LoanStatus='O' OR L.LoanStatus='b') AND BranchId = pBranchId;
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET vCompleted=0;
	CREATE TEMPORARY TABLE EwiDueRows(LoanCode CHAR(10), BranchId INT, MemberCode CHAR(9), MemberName VARCHAR(50), Phone VARCHAR(10), NoOfInstalments INT, EWI INT, PendingAmount INT, DueDate DATE);
	OPEN EWIDueCursor;
	SET vCompleted:=1;
	CursorLoop:LOOP
		FETCH EWIDueCursor INTO vLoanCode, vBranchId, vMemberCode, vMemberName, vPhone, vLoanAmount, vTenure, vEwi, vLoanDisposalDate;
		IF vCompleted=0 THEN
			LEAVE CursorLoop;
		END IF;
		SET vWeeksCompleted := FLOOR(DATEDIFF(SYSDATE(), vLoanDisposalDate)/7);
		IF vWeeksCompleted > vTenure THEN
			SET vWeeksCompleted := vTenure;
		END IF;
		SELECT SUM(ReceiptAmount) INTO vAmountPaid FROM CashReceipt WHERE LoanCode = vLoanCode AND (ReceiptType='I' OR ReceiptType='S');
		IF vAmountPaid IS NULL THEN
			SET vAmountPaid := 0;
		END IF;
		SET vWeeksPaid := vAmountPaid/vEWI;
		SET vNoOfInstalments := vWeeksCompleted - vWeeksPaid;
        SET vPendingAmount := vEWI*vTenure - vAmountPaid;
		IF vNoOfInstalments >= 1 THEN
			SET vDueDate := DATE_ADD(vLoanDisposalDate, INTERVAL (vWeeksPaid + 1)*7 DAY);
            INSERT INTO EwiDueRows VALUES(vLoanCode, vBranchId, vMemberCode, vMemberName, vPhone,vNoOfInstalments, vEWI, vPendingAmount, vDueDate);
		END IF;
	END LOOP;
	SELECT * FROM EwiDueRows;
	DROP TABLE EwiDueRows;
END;//
DELIMITER ;




-- GetRepaymentStatusGroupInfo
-- ersion 2.0
DELIMITER //
DROP PROCEDURE IF EXISTS `GetRepaymentStatusGroupInfo`//
CREATE PROCEDURE GetRepaymentStatusGroupInfo(pGroupCode CHAR(7)) 
BEGIN
	SELECT 
		MG.GroupCode,
		MG.GroupName,
		IFNULL((SELECT 
						MemberName
					FROM
						Member M
					WHERE
						M.GroupCode = MG.GroupCode
							AND M.MemberType = 1),
				'NA') AS LeaderName,
		L.LoanAmount,
		L.LoanDate,
		L.Tenure,
		L.EWI
	FROM
		MemberGroup MG
			INNER JOIN
		Member M ON MG.GroupCode = M.GroupCode
			INNER JOIN
		Loan L ON M.MemberCode = L.MemberCode
	WHERE
		MG.GroupCode = pGroupCode
			AND L.LoanStatus <> 'C' 
	LIMIT 1;
END;//
DELIMITER ;

-- GetRepaymentStatusMemberCount
-- Version 2.0
DELIMITER //
DROP PROCEDURE IF EXISTS `GetRepaymentStatusMemberCount`//
CREATE PROCEDURE GetRepaymentStatusMemberCount(pGroupCode CHAR(7)) 
BEGIN
	SELECT 
		COUNT(*) AS MemberCount
	FROM
		Member M
			INNER JOIN
		Loan L ON M.MemberCode = L.MemberCode
	WHERE
		M.GroupCode = pGroupCode
			AND L.LoanStatus <> 'C';
END;//
DELIMITER ;

-- GetRepaymentStatusMemberInfo
-- Version 2.0 (Updated 23 Jan 2020)
DELIMITER //
DROP PROCEDURE IF EXISTS `GetRepaymentStatusMemberInfo`//
CREATE PROCEDURE GetRepaymentStatusMemberInfo(pGroupCode CHAR(7)) 
BEGIN
	SELECT 
		M.MemberCode,
		M.MemberName,
		L.LoanCode,
		L.EWI
	FROM
		Member M
			INNER JOIN
		Loan L ON M.MemberCode = L.MemberCode
	WHERE
		M.GroupCode = pGroupCode
			AND L.LoanStatus <> 'C';
END;//
DELIMITER ;

-- GetPaymentDates
-- Version 2.0
DELIMITER //
DROP PROCEDURE IF EXISTS `GetPaymentDates`//
CREATE PROCEDURE GetPaymentDates(pLoanCode CHAR(10)) 
BEGIN
	SELECT 
		ActualReceiptDate,
		ReceiptAmount
	FROM
		CashReceipt
	WHERE
		LoanCode = pLoanCode
			AND ReceiptType <> 'P'
	ORDER BY ReceiptId;
END;//
DELIMITER ;

-- GetEWIDay
-- Version 2.0
DELIMITER //
DROP FUNCTION IF EXISTS `GetEWIDay`//
CREATE FUNCTION GetEWIDay(pGroupCode CHAR(7)) RETURNS VARCHAR(15)
READS SQL DATA
BEGIN
	DECLARE vEWIDay VARCHAR(15);
	SELECT 
		DAYNAME(L.LoanDisposalDate) INTO vEWIDay
	FROM
		MemberGroup MG
			INNER JOIN
		Member M ON MG.GroupCode = M.GroupCode
			INNER JOIN
		Loan L ON M.MemberCode = L.MemberCode
	WHERE
		MG.GroupCode = pGroupCode
			AND L.LoanStatus <> 'C' 
	LIMIT 1;
	RETURN vEWIDay;
END//
DELIMITER ;
-- Test
SELECT GetEWIDay(1);

-- GetEWI
-- Version 2.0 
DELIMITER //
DROP FUNCTION IF EXISTS `GetEWI`//
CREATE FUNCTION GetEWI(pGroupCode CHAR(7)) RETURNS INT
READS SQL DATA
BEGIN
	DECLARE vEWI INT;
	SELECT 
		AVG(EWI) INTO vEWI
	FROM
		MemberGroup MG
			INNER JOIN
		Member M ON MG.GroupCode = M.GroupCode
			INNER JOIN
		Loan L ON M.MemberCode = L.MemberCode
	WHERE
		MG.GroupCode = pGroupCode
			AND L.LoanStatus <> 'C';
	-- LIMIT 1;
	RETURN vEWI;
END//
DELIMITER ;
-- Test
SELECT GetEWI(1);

--GetTotalEWI 
--Version 3.0
DELIMITER //
DROP FUNCTION IF EXISTS `GetTotalEWI`//
CREATE FUNCTION GetTotalEWI(pGroupCode CHAR(7)) RETURNS INT
READS SQL DATA
BEGIN
    DECLARE vTotalEWI INT;
    SELECT 
        SUM(L.EWI * L.Tenure) INTO vTotalEWI  -- âœ… Sum the product
    FROM
        MemberGroup MG
            INNER JOIN
        Member M ON MG.GroupCode = M.GroupCode
            INNER JOIN
        Loan L ON M.MemberCode = L.MemberCode
    WHERE
        MG.GroupCode = pGroupCode
            AND L.LoanStatus <> 'C'; 
    RETURN vTotalEWI;
END//
DELIMITER ;
-- Test
SELECT GetTotalEWI('0010101');

--GetTenure
--Version 2.0 
DELIMITER //
DROP FUNCTION IF EXISTS `GetTenure`//
CREATE FUNCTION GetTenure(pGroupCode CHAR(7)) RETURNS INT
READS SQL DATA
BEGIN
	DECLARE vTenure INT;
	SELECT 
		Tenure INTO vTenure
	FROM
		MemberGroup MG
			INNER JOIN
		Member M ON MG.GroupCode = M.GroupCode
			INNER JOIN
		Loan L ON M.MemberCode = L.MemberCode
	WHERE
		MG.GroupCode = pGroupCode
			AND L.LoanStatus <> 'C'
	LIMIT 1;
	RETURN vTenure;
END//
DELIMITER ;
-- Test
SELECT GetTenure('0010101');


--GetTotalMembers
--Version 2.0
DELIMITER //
DROP FUNCTION IF EXISTS `GetTotalMembers`//
CREATE FUNCTION GetTotalMembers(pGroupCode CHAR(7)) RETURNS INT
READS SQL DATA
BEGIN
	DECLARE vTotalMembers INT;
	SELECT 
		COUNT(*) INTO vTotalMembers
	FROM
		Member M
			INNER JOIN
		Loan L ON M.MemberCode = L.MemberCode
	WHERE
		M.GroupCode = pGroupCode
			AND L.LoanStatus <> 'C';
	RETURN vTotalMembers;
END//
DELIMITER ;
-- Test
SELECT GetTotalMembers(1);


--GetTotalEWIReceived
--Version 2.0
DELIMITER //
DROP FUNCTION IF EXISTS `GetTotalEWIReceived`//
CREATE FUNCTION GetTotalEWIReceived(pGroupCode CHAR(7)) RETURNS INT
READS SQL DATA
BEGIN
	DECLARE vTotalEWIReceived INT;
	SELECT 
		SUM(ReceiptAmount) INTO vTotalEWIReceived
	FROM
		Member M
			INNER JOIN
		Loan L ON M.MemberCode = L.MemberCode
			INNER JOIN
		CashReceipt CR ON CR.LoanCode = L.LoanCode
	WHERE
		M.GroupCode = pGroupCode
			AND L.LoanStatus <> 'C' AND (CR.ReceiptType='I'OR CR.ReceiptType='S');
	IF vTotalEWIReceived IS NULL THEN
		SET vTotalEWIReceived:=0;
	END IF;
	RETURN vTotalEWIReceived;
END//
DELIMITER ;
-- Test
SELECT GetTotalEWIReceived('0010101');

--GetLeaderName
--Version 2.0
DELIMITER //
DROP FUNCTION IF EXISTS `GetLeaderName`//
CREATE FUNCTION GetLeaderName(pGroupCode CHAR(7)) RETURNS VARCHAR(50)
READS SQL DATA
BEGIN
	DECLARE vLeaderName VARCHAR(50);
	SELECT 
		MemberName INTO vLeaderName
	FROM
		MemberGroup MG
			INNER JOIN
		Member M ON MG.GroupCode = M.GroupCode
	WHERE
		M.MemberType = 1 AND MG.GroupCode = pGroupCode;
	IF vLeaderName IS NULL THEN
		SET vLeaderName:= 'NA';
	END IF;
	RETURN vLeaderName;
END//
DELIMITER ;
-- Test
SELECT GetLeaderName(1);


DELIMITER //
DROP FUNCTION IF EXISTS `GetAverageLoanAmount`//
CREATE FUNCTION GetAverageLoanAmount(pGroupCode CHAR(7)) RETURNS INT
READS SQL DATA
BEGIN
    DECLARE vAverageLoanAmount INT;
    SELECT 
        AVG(L.LoanAmount) INTO vAverageLoanAmount
    FROM
        MemberGroup MG
            INNER JOIN
        Member M ON MG.GroupCode = M.GroupCode
            INNER JOIN
        Loan L ON M.MemberCode = L.MemberCode
    WHERE
        MG.GroupCode = pGroupCode
            AND L.LoanStatus <> 'C';
    RETURN COALESCE(vAverageLoanAmount, 0);
END//
DELIMITER ;


DELIMITER //
DROP FUNCTION IF EXISTS `GetWeeksCompleted`//
CREATE FUNCTION GetWeeksCompleted(pGroupCode CHAR(7)) RETURNS INT
READS SQL DATA
BEGIN
    DECLARE vWeeksCompleted INT;
    DECLARE vTotalMembers INT;
    DECLARE vTotalEWIExpected INT;
    DECLARE vTotalEWIReceived INT;
    
    -- Get total members with active loans
    SELECT COUNT(*) INTO vTotalMembers
    FROM Member M
        INNER JOIN Loan L ON M.MemberCode = L.MemberCode
    WHERE M.GroupCode = pGroupCode
        AND L.LoanStatus <> 'C';
    
    -- If no members, return 0
    IF vTotalMembers = 0 THEN
        RETURN 0;
    END IF;
    
    -- Get total EWI received (instalment receipts only, ReceiptType = 'I')
    SELECT COALESCE(SUM(ReceiptAmount), 0) INTO vTotalEWIReceived
    FROM Member M
        INNER JOIN Loan L ON M.MemberCode = L.MemberCode
        INNER JOIN CashReceipt CR ON CR.LoanCode = L.LoanCode
    WHERE M.GroupCode = pGroupCode
        AND L.LoanStatus <> 'C'
        AND CR.ReceiptType = 'I';
    
    -- Get total EWI amount per member (average EWI * total members * tenure for first member)
    -- This represents the expected total collection
    SELECT COALESCE(AVG(L.EWI), 0) INTO vTotalEWIExpected
    FROM Member M
        INNER JOIN Loan L ON M.MemberCode = L.MemberCode
    WHERE M.GroupCode = pGroupCode
        AND L.LoanStatus <> 'C';
    
    -- Calculate weeks completed: Total EWI Received / (Total Members * Average EWI per week)
    -- Formula: Weeks = Total Received / (Members * Weekly Rate)
    IF vTotalEWIExpected > 0 AND vTotalMembers > 0 THEN
        SET vWeeksCompleted = ROUND(vTotalEWIReceived / (vTotalMembers * vTotalEWIExpected));
    ELSE
        SET vWeeksCompleted = 0;
    END IF;
    
    RETURN vWeeksCompleted;
END//
DELIMITER ;

DELIMITER //
DROP FUNCTION IF EXISTS `GetAverageEWIReceived`//
CREATE FUNCTION GetAverageEWIReceived(pGroupCode CHAR(7)) RETURNS INT
READS SQL DATA
BEGIN
    DECLARE vAverageEWIReceived INT;
    DECLARE vTotalMembers INT;
    DECLARE vWeeksCompleted INT;
    DECLARE vTotalEWIReceived INT;
    
    -- Get total members with active loans
    SELECT COUNT(*) INTO vTotalMembers
    FROM Member M
        INNER JOIN Loan L ON M.MemberCode = L.MemberCode
    WHERE M.GroupCode = pGroupCode
        AND L.LoanStatus <> 'C';
    
    -- Get weeks completed
    SELECT GetWeeksCompleted(pGroupCode) INTO vWeeksCompleted;
    
    -- Get total EWI received
    SELECT COALESCE(SUM(ReceiptAmount), 0) INTO vTotalEWIReceived
    FROM Member M
        INNER JOIN Loan L ON M.MemberCode = L.MemberCode
        INNER JOIN CashReceipt CR ON CR.LoanCode = L.LoanCode
    WHERE M.GroupCode = pGroupCode
        AND L.LoanStatus <> 'C'
        AND CR.ReceiptType = 'I';
    
    -- Calculate average EWI received per week
    -- Formula: Total Received / Weeks Completed
    IF vWeeksCompleted > 0 THEN
        SET vAverageEWIReceived = ROUND(vTotalEWIReceived / vWeeksCompleted);
    ELSE
        SET vAverageEWIReceived = 0;
    END IF;
    
    RETURN vAverageEWIReceived;
END//
DELIMITER ;

-- GetCumulativeReport
-- Version 2.0
DELIMITER //
DROP PROCEDURE IF EXISTS `GetCumulativeReport`//
CREATE PROCEDURE GetCumulativeReport() 
BEGIN
    SELECT * FROM (
        SELECT 
            GroupCode,
            GroupName,
            GetLeaderName(GroupCode) AS LeaderName,
            GetEWIDay(GroupCode) AS EWIDay,
            GetAverageLoanAmount(GroupCode) AS AverageLoanAmount,
            GetTenure(GroupCode) AS Tenure,
            GetWeeksCompleted(GroupCode) AS WeeksCompleted,
            GetAverageEWIReceived(GroupCode) AS AverageEWIReceived,
            GetTotalEWI(GroupCode) AS TotalEwi,
            GetTotalMembers(GroupCode) AS TotalMembers,
            GetEWI(GroupCode) AS Ewi,
            GetTotalEWIReceived(GroupCode) AS TotalEwiReceived
        FROM MemberGroup
    ) AS MG
    WHERE MG.EwiDay IS NOT NULL;
END//
DELIMITER ;

CALL GetCumulativeReport();

-- GetGroupPFStatus
-- Version 2.0 (GroupId to GroupCode)
DELIMITER //
DROP PROCEDURE IF EXISTS `GetGroupPFStatus`//
CREATE PROCEDURE GetGroupPFStatus(pGroupCode CHAR(7), OUT pProcessingFee INT, OUT pInsurance INT, OUT pStatusCode INT)
BEGIN
	DECLARE vMemberCount INT;
	DECLARE vApprovedCount INT;
	SELECT COUNT(*) INTO vMemberCount FROM Member WHERE GroupCode = pGroupCode;
	SELECT 
		COUNT(*) INTO vApprovedCount
	FROM
		MemberGroup MG
			INNER JOIN
		Member M ON MG.GroupCode = M.GroupCode
			INNER JOIN
		Loan L ON M.MemberCode = L.MemberCode
	WHERE
		MG.GroupCode = pGroupCode
			AND L.LoanStatus = 'A'; 
	IF vMemberCount=vApprovedCount THEN
		
		SELECT 
			ProcessingFee, Insurance INTO pProcessingFee, pInsurance
		FROM
			MemberGroup MG
				INNER JOIN
			Member M ON MG.GroupCode = M.GroupCode
				INNER JOIN
			Loan L ON M.MemberCode = L.MemberCode
		WHERE
			MG.GroupCode = pGroupCode
		LIMIT 1;
		SET pStatusCode := 1;
	ELSE
		SET pStatusCode := 0;
		SET pProcessingFee := 0;
		SET pInsurance := 0;

	END IF;
END;//
DELIMITER ;

-- GetGroupMembersLoan
-- Version 2.0
DELIMITER //
DROP PROCEDURE IF EXISTS `GetGroupMembersLoan`//
CREATE PROCEDURE GetGroupMembersLoan(pGroupCode CHAR(7))
BEGIN
	SELECT 
		M.MemberCode, M.MemberName, L.LoanCode, L.LoanAmount, L.ProcessingFee, L.Insurance
	FROM
		MemberGroup MG
			INNER JOIN
		Member M ON MG.GroupCode = M.GroupCode
			INNER JOIN
		Loan L ON M.MemberCode = L.MemberCode
	WHERE
		MG.GroupCode = pGroupCode AND L.LoanStatus = 'A';
END//
DELIMITER ;
-- Test
CALL GetGroupMembersLoan(5);


-- GetLoanInfo
-- Version 2.0
DELIMITER //
DROP PROCEDURE IF EXISTS `GetLoanInfo`//
CREATE PROCEDURE GetLoanInfo(pLoanCode CHAR(10), OUT pEwi INT, OUT pNoOfInstalments INT)
BEGIN
	DECLARE vTenure INT;
	DECLARE vLoanDisposalDate DATE;
	DECLARE vWeeksCompleted INT;
	DECLARE vWeeksPaid INT;
	DECLARE vAmountPaid INT;
	SET pNoOfInstalments := 0;
	SELECT Tenure, LoanDate, EWI INTO vTenure, vLoanDisposalDate, pEwi FROM Loan WHERE LoanCode = pLoanCode;
	SET vWeeksCompleted := FLOOR(DATEDIFF(SYSDATE(),vLoanDisposalDate)/7);
	IF vWeeksCompleted > vTenure THEN
		SET vWeeksCompleted := vTenure;
	END IF;
	SELECT SUM(ReceiptAmount) INTO vAmountPaid FROM CashReceipt WHERE LoanCode = pLoanCode AND ReceiptType='I';
	IF vAmountPaid IS NULL THEN
		SET vAmountPaid := 0;
	END IF;
	SET vWeeksPaid := vAmountPaid/pEwi;
	SET pNoOfInstalments := vWeeksCompleted - vWeeksPaid;
END//
DELIMITER ;

-- GetGroupMembersOngoingLoan
-- Version 2.0
DELIMITER //
DROP PROCEDURE IF EXISTS `GetGroupMembersOngoingLoan`//
CREATE PROCEDURE GetGroupMembersOngoingLoan(pGroupCode CHAR(7))
BEGIN
	SELECT 
		M.MemberCode, M.MemberName, L.LoanCode, L.LoanAmount, L.ProcessingFee, L.Insurance, L.Ewi
	FROM
		MemberGroup MG
			INNER JOIN
		Member M ON MG.GroupCode = M.GroupCode
			INNER JOIN
		Loan L ON M.MemberCode = L.MemberCode
	WHERE
		MG.GroupCode = pGroupCode AND L.LoanStatus = 'O';
END//
DELIMITER ; 
-- Test
CALL GetGroupMembersOngoingLoan(5);

-- GetGroupInstalmentStatus
-- Version 2.0
DELIMITER //
DROP PROCEDURE IF EXISTS `GetGroupInstalmentStatus`//
CREATE PROCEDURE GetGroupInstalmentStatus(pGroupCode CHAR(7), OUT pNoOfInstalments INT, OUT pEWI INT, OUT pStatusCode INT)
GetGroupInstalmentStatus:BEGIN
	DECLARE vCompleted INT;
	DECLARE vEwi INT;
	DECLARE vNoOfInstalments INT;
	DECLARE vLoanCode CHAR(13);
	DECLARE cMemberLoan CURSOR FOR 
		SELECT 
			L.LoanCode
		FROM
			MemberGroup MG
				INNER JOIN
			Member M ON MG.GroupCode = M.GroupCode
				INNER JOIN
			Loan L ON M.MemberCode = L.MemberCode
		WHERE
			MG.GroupCode = pGroupCode AND L.LoanStatus = 'O';
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET vCompleted=0;
	
	SET pNoOfInstalments:=0;
	SET pEWI:=0;
	SET vCompleted:=1;
	SET pStatusCode:=1;
	OPEN cMemberLoan;
	CursorLoop: LOOP
		FETCH cMemberLoan INTO vLoanCode;
		IF vCompleted=0 THEN
			LEAVE CursorLoop;
		END IF;
		CALL GetLoanInfo(vLoanCode, vEwi, vNoOfInstalments);
		IF pEWI=0 THEN
			SET pEWI:=vEWI;
			SET pNoOfInstalments:=vNoOfInstalments;
		ELSE
			IF pNoOfInstalments<>vNoOfInstalments THEN
				SET pStatusCode:=1;
				LEAVE GetGroupInstalmentStatus;
			END IF;
		END IF;
	END LOOP;
END;//
DELIMITER ;


-- GetCashReceiptStatement ()
-- Version 2.0
DELIMITER //
DROP PROCEDURE IF EXISTS `GetCashReceiptStatement`//
CREATE PROCEDURE GetCashReceiptStatement(pFromDate DATE, pToDate DATE)
BEGIN
	SELECT 
		R.ReceiptId,
		L.MemberCode,
		M.MemberName,
		L.LoanCode,
		R.Description,
		R.ActualReceiptDate,
		R.ReceiptAmount AS Amount
	FROM 
		CashReceipt R INNER JOIN Loan L ON R.LoanCode=L.LoanCode 
			INNER JOIN Member M ON L.MemberCode=M.MemberCode 
			WHERE ActualReceiptDate BETWEEN pFromDate AND pToDate ORDER BY R.ReceiptId;
END//
DELIMITER ;

-- getmember
-- getallmembers


DELIMITER //
DROP PROCEDURE IF EXISTS `GetPreClosureDetails`//
CREATE PROCEDURE GetPreClosureDetails(
    pLoanCode CHAR(10), 
    OUT pLoanStatus VARCHAR(1), 
    OUT pMemberCode CHAR(9), 
    OUT pMemberName VARCHAR(50),
    OUT pLoanAmount INT,
    OUT pInterestRate DECIMAL(5,2),
    OUT pTenure INT,
    OUT pLoanDisposalDate DATE,
    OUT pEwi INT, 
    OUT pTotalPendingInstalments INT,
    OUT pTotalDue INT,
    OUT pSuggestedDiscount INT,
    OUT pInterestSavings INT,
    OUT pDelayPenalty INT,
    OUT pAdvanceBenefit INT
)
GetPreClosureDetails:BEGIN
    DECLARE vWeeksCompleted INT;
    DECLARE vWeeksPaid INT;
    DECLARE vAmountPaid INT;
    DECLARE vBalance DECIMAL(10,2);
    DECLARE vInterest DECIMAL(10,2);
    DECLARE vPrincipal DECIMAL(10,2);
    DECLARE vFactor DECIMAL(20,10);
    DECLARE vTotalInterestRemaining DECIMAL(10,2);
    DECLARE vCurrentWeek INT;
    DECLARE vDaysDiff INT;
    DECLARE vPaymentAdjustment DECIMAL(10,2);
    DECLARE vReceiptDate DATE;
    DECLARE vExpectedDate DATE;
    DECLARE vReceiptAmount INT;
    DECLARE done INT DEFAULT FALSE;
    
    -- Cursor for receipts
    DECLARE receipt_cursor CURSOR FOR 
        SELECT ActualReceiptDate, ReceiptAmount
        FROM CashReceipt 
        WHERE LoanCode = pLoanCode AND ReceiptType = 'I'
        ORDER BY ReceiptDate;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    SET pLoanStatus := 'N';
    SET pTotalPendingInstalments := 0;
    SET pSuggestedDiscount := 0;
    SET pInterestSavings := 0;
    SET pDelayPenalty := 0;
    SET pAdvanceBenefit := 0;
    
    -- Get loan details
    SELECT MemberCode, LoanAmount, InterestRate, Tenure, LoanDisposalDate, EWI, LoanStatus 
    INTO pMemberCode, pLoanAmount, pInterestRate, pTenure, pLoanDisposalDate, pEwi, pLoanStatus 
    FROM Loan 
    WHERE LoanCode = pLoanCode;
    
    IF pMemberCode IS NULL THEN
        SET pLoanStatus := 'I';
        LEAVE GetPreClosureDetails;
    END IF;
    
    SELECT MemberName INTO pMemberName FROM Member WHERE MemberCode = pMemberCode;
    
    IF pLoanStatus = 'O' THEN
        -- Calculate weeks completed and paid
        SET vWeeksCompleted := FLOOR(DATEDIFF(SYSDATE(), pLoanDisposalDate) / 7);
        IF vWeeksCompleted > pTenure THEN
            SET vWeeksCompleted := pTenure;
        END IF;
        
        SELECT COALESCE(SUM(ReceiptAmount), 0) INTO vAmountPaid 
        FROM CashReceipt 
        WHERE LoanCode = pLoanCode AND ReceiptType = 'I';
        
        SET vWeeksPaid := vAmountPaid / pEwi;
        SET pTotalPendingInstalments := pTenure - vWeeksPaid;
        SET pTotalDue := pTotalPendingInstalments * pEwi;
        
        -- Calculate interest savings on remaining instalments
        SET vFactor := POW(1 + pInterestRate / 5200, pTenure);
        SET vBalance := pLoanAmount;
        SET vTotalInterestRemaining := 0;
        
        -- Loop through paid instalments to get current balance
        SET vCurrentWeek := 1;
        WHILE vCurrentWeek <= vWeeksPaid DO
            SET vInterest := vBalance * pInterestRate / 100 / 52;
            SET vPrincipal := pEwi - vInterest;
            SET vBalance := vBalance - vPrincipal;
            SET vCurrentWeek := vCurrentWeek + 1;
        END WHILE;
        
        -- Calculate interest for remaining instalments
        SET vCurrentWeek := vWeeksPaid + 1;
        WHILE vCurrentWeek <= pTenure DO
            SET vInterest := vBalance * pInterestRate / 100 / 52;
            SET vPrincipal := pEwi - vInterest;
            SET vTotalInterestRemaining := vTotalInterestRemaining + vInterest;
            SET vBalance := vBalance - vPrincipal;
            SET vCurrentWeek := vCurrentWeek + 1;
        END WHILE;
        
        SET pInterestSavings := ROUND(vTotalInterestRemaining);
        
        -- Calculate delay penalty AND advance benefit
        -- Process each receipt to check if paid early or late
        SET vPaymentAdjustment := 0;
        SET vCurrentWeek := 0;
        SET vBalance := pLoanAmount;
        
        OPEN receipt_cursor;
        
        read_loop: LOOP
            FETCH receipt_cursor INTO vReceiptDate, vReceiptAmount;
            IF done THEN
                LEAVE read_loop;
            END IF;
            
            -- Calculate how many instalments this receipt covers
            SET vCurrentWeek := vCurrentWeek + (vReceiptAmount / pEwi);
            
            -- Expected date for this instalment (approximate)
            SET vExpectedDate := DATE_ADD(pLoanDisposalDate, INTERVAL vCurrentWeek * 7 DAY);
            
            -- Calculate days difference (negative = advance, positive = delay)
            SET vDaysDiff := DATEDIFF(vReceiptDate, vExpectedDate);
            
            -- Calculate daily interest on the outstanding balance
            -- Using the current balance for calculation
            IF vDaysDiff != 0 THEN
                -- Daily interest rate applied to the receipt amount
                SET vPaymentAdjustment := vPaymentAdjustment + 
                    (vReceiptAmount * pInterestRate / 100 / 365 * vDaysDiff);
            END IF;
            
            -- Update balance (simplified)
            SET vInterest := vBalance * pInterestRate / 100 / 52 * (vReceiptAmount / pEwi);
            SET vPrincipal := vReceiptAmount - vInterest;
            SET vBalance := vBalance - vPrincipal;
            
        END LOOP;
        
        CLOSE receipt_cursor;
        
        -- Separate into delay penalty and advance benefit
        IF vPaymentAdjustment > 0 THEN
            -- Positive means delays (member paid late)
            SET pDelayPenalty := ROUND(vPaymentAdjustment);
            SET pAdvanceBenefit := 0;
        ELSE
            -- Negative means advances (member paid early)
            SET pDelayPenalty := 0;
            SET pAdvanceBenefit := ROUND(ABS(vPaymentAdjustment));
        END IF;
        
        -- Calculate suggested discount: Interest Savings - Delay Penalty + Advance Benefit
        SET pSuggestedDiscount := pInterestSavings - pDelayPenalty + pAdvanceBenefit;
        
        -- Ensure discount is not negative or more than total due
        IF pSuggestedDiscount < 0 THEN
            SET pSuggestedDiscount := 0;
        END IF;
        
        IF pSuggestedDiscount > pTotalDue THEN
            SET pSuggestedDiscount := pTotalDue;
        END IF;
        
    ELSE
        SET pEwi := 0;
    END IF;
END//
DELIMITER ;

DELIMITER //
DROP PROCEDURE IF EXISTS `GeneratePreClosureReceipt`//
CREATE PROCEDURE GeneratePreClosureReceipt(
    pLoanCode VARCHAR(10), 
    pPreClosureDiscount INT, 
    pActualReceiptDate DATE, 
    pUserId VARCHAR(20), 
    OUT pReceiptId INT
)
BEGIN
    DECLARE vTenure INT;
    DECLARE vLoanDisposalDate DATE;
    DECLARE vEWI INT;
    DECLARE vAmountPaid INT;
    DECLARE vWeeksPaid INT;
    DECLARE vPendingInstalments INT;
    DECLARE vTotalDue INT;
    DECLARE vNetAmount INT;
    DECLARE vDescription VARCHAR(100);
    
    -- Get loan details
    SELECT Tenure, LoanDisposalDate, EWI 
    INTO vTenure, vLoanDisposalDate, vEWI 
    FROM Loan 
    WHERE LoanCode = pLoanCode;
    
    -- Calculate amount already paid
    SELECT COALESCE(SUM(ReceiptAmount), 0) 
    INTO vAmountPaid 
    FROM CashReceipt 
    WHERE LoanCode = pLoanCode AND ReceiptType = 'I';
    
    -- Calculate weeks paid and pending instalments
    SET vWeeksPaid := vAmountPaid / vEWI;
    SET vPendingInstalments := vTenure - vWeeksPaid;
    
    -- Calculate total due and net amount after discount
    SET vTotalDue := vPendingInstalments * vEWI;
    SET vNetAmount := vTotalDue - pPreClosureDiscount;
    
    -- Create description
    SET vDescription := CONCAT(
        'Pre-Closure: ', 
        CAST(vPendingInstalments AS CHAR), 
        ' instalments (Total: â‚¹', 
        CAST(vTotalDue AS CHAR),
        ', Discount: â‚¹',
        CAST(pPreClosureDiscount AS CHAR),
        ', Net: â‚¹',
        CAST(vNetAmount AS CHAR),
        ')'
    );
    
    SAVEPOINT Trans;
    
    -- Insert pre-closure receipt
    INSERT INTO CashReceipt(
        LoanCode, 
        ReceiptType, 
        ReceiptAmount, 
        ReceiptDate, 
        Description, 
        ActualReceiptDate, 
        UserId
    )
    VALUES(
        pLoanCode, 
        'S', 
        vNetAmount, 
        SYSDATE(), 
        vDescription, 
        pActualReceiptDate, 
        pUserId
    );
    
    -- Update loan status to 'S' (Settled) and save discount
    UPDATE Loan 
    SET LoanStatus = 'S', 
        PreClosureDiscount = pPreClosureDiscount 
    WHERE LoanCode = pLoanCode;
    
    SET pReceiptId := LAST_INSERT_ID();
    
    COMMIT;
END//
DELIMITER ;

DELIMITER //
DROP PROCEDURE IF EXISTS `MarkLoanAsBad`//
CREATE PROCEDURE MarkLoanAsBad(
    pLoanCode CHAR(10),
    pUserId VARCHAR(20),
    pStatusRemarks VARCHAR(50)
)
BEGIN
    DECLARE vCurrentStatus CHAR(1);
    
    -- Get current loan status
    SELECT LoanStatus INTO vCurrentStatus 
    FROM Loan 
    WHERE LoanCode = pLoanCode;
    
    -- Only allow marking as bad if loan is currently Ongoing
    IF vCurrentStatus = 'O' THEN
        UPDATE Loan 
        SET LoanStatus = 'b',
            StatusRemarks = pStatusRemarks,
            ApprovedBy = pUserId
        WHERE LoanCode = pLoanCode;
        
        SELECT 1 AS StatusCode, 'Loan marked as bad loan' AS Message;
    ELSE
        SELECT 0 AS StatusCode, 'Only ongoing loans can be marked as bad' AS Message;
    END IF;
END//
DELIMITER ;

DELIMITER //
DROP PROCEDURE IF EXISTS `GetBadLoanDetails`//
CREATE PROCEDURE GetBadLoanDetails(
    pLoanCode CHAR(10),
    OUT pLoanStatus CHAR(1),
    OUT pMemberCode CHAR(9),
    OUT pMemberName VARCHAR(50),
    OUT pLoanAmount INT,
    OUT pTotalDue INT,
    OUT pAmountPaid INT,
    OUT pPendingAmount INT
)
GetBadLoanDetails:BEGIN
    DECLARE vTenure INT;
    DECLARE vEWI INT;
    DECLARE vProcessingFee INT;
    DECLARE vInsurance INT;
    
    SET pLoanStatus := 'N';
    SET pTotalDue := 0;
    SET pAmountPaid := 0;
    SET pPendingAmount := 0;
    
    -- Get loan details
    SELECT MemberCode, LoanAmount, Tenure, EWI, ProcessingFee, Insurance, LoanStatus
    INTO pMemberCode, pLoanAmount, vTenure, vEWI, vProcessingFee, vInsurance, pLoanStatus
    FROM Loan 
    WHERE LoanCode = pLoanCode;
    
    IF pMemberCode IS NULL THEN
        SET pLoanStatus := 'I';
        LEAVE GetBadLoanDetails;
    END IF;
    
    -- Get member name
    SELECT MemberName INTO pMemberName FROM Member WHERE MemberCode = pMemberCode;
    
    IF pLoanStatus = 'b' THEN
        -- Calculate total due (all instalments + processing fee + insurance)
        SET pTotalDue := vTenure * vEWI;
        
        -- Calculate amount already paid (all receipts for this loan)
        SELECT COALESCE(SUM(ReceiptAmount), 0) INTO pAmountPaid
        FROM CashReceipt 
        WHERE LoanCode = pLoanCode AND (ReceiptType='I' OR ReceiptType='S');
        
        -- Calculate pending amount
        SET pPendingAmount := pTotalDue - pAmountPaid;
        
        -- Ensure pending amount is not negative
        IF pPendingAmount < 0 THEN
            SET pPendingAmount := 0;
        END IF;
    ELSE
        SET pLoanAmount := 0;
    END IF;
END//
DELIMITER ;

-- Generate Bad Loan Receipt
DELIMITER //
DROP PROCEDURE IF EXISTS `GenerateBadLoanReceipt`//
CREATE PROCEDURE GenerateBadLoanReceipt(
    pLoanCode VARCHAR(10),
    pPaymentAmount INT,
    pSettlementDiscount INT,
    pActualReceiptDate DATE,
    pUserId VARCHAR(20),
    OUT pReceiptId INT,
    OUT pRemainingBalance INT,
    OUT pIsFullSettlement TINYINT
)
BEGIN
    DECLARE vTenure INT;
    DECLARE vEWI INT;
    DECLARE vProcessingFee INT;
    DECLARE vInsurance INT;
    DECLARE vTotalDue INT;
    DECLARE vAmountPaid INT;
    DECLARE vPendingAmount INT;
    DECLARE vDescription VARCHAR(100);
    DECLARE vTotalPayment INT;
    
    -- Get loan details
    SELECT Tenure, EWI, ProcessingFee, Insurance
    INTO vTenure, vEWI, vProcessingFee, vInsurance
    FROM Loan 
    WHERE LoanCode = pLoanCode;
    
    -- Calculate total due
    SET vTotalDue := (vTenure * vEWI);
    
    -- Calculate amount already paid
    SELECT COALESCE(SUM(ReceiptAmount), 0) INTO vAmountPaid
    FROM CashReceipt 
    WHERE LoanCode = pLoanCode AND (ReceiptType='I' OR ReceiptType='S');
    
    -- Calculate pending amount before this payment
    SET vPendingAmount := vTotalDue - vAmountPaid;
    
    -- Total effective payment (payment + discount)
    SET vTotalPayment := pPaymentAmount + pSettlementDiscount;
    
    -- Calculate remaining balance after this payment
    SET pRemainingBalance := vPendingAmount - vTotalPayment;
    
    -- Check if this is full settlement
    IF pRemainingBalance <= 0 THEN
        SET pIsFullSettlement := 1;
        SET pRemainingBalance := 0;
    ELSE
        SET pIsFullSettlement := 0;
    END IF;
    
    -- Create description
    IF pIsFullSettlement = 1 THEN
        IF pSettlementDiscount > 0 THEN
            SET vDescription := CONCAT('Bad Loan Settlement (Payment: â‚¹', 
                                      CAST(pPaymentAmount AS CHAR),
                                      ', Discount: â‚¹',
                                      CAST(pSettlementDiscount AS CHAR),
                                      ')');
        ELSE
            SET vDescription := CONCAT('Bad Loan Full Settlement (â‚¹', 
                                      CAST(pPaymentAmount AS CHAR),
                                      ')');
        END IF;
    ELSE
        SET vDescription := CONCAT('Bad Loan Part Payment (â‚¹', 
                                  CAST(pPaymentAmount AS CHAR),
                                  ', Pending: â‚¹',
                                  CAST(pRemainingBalance AS CHAR),
                                  ')');
    END IF;
    
    SAVEPOINT Trans;
    
    -- Insert receipt for the payment
    INSERT INTO CashReceipt(
        LoanCode, 
        ReceiptType, 
        ReceiptAmount, 
        ReceiptDate, 
        Description, 
        ActualReceiptDate, 
        UserId
    )
    VALUES(
        pLoanCode, 
        'S', 
        pPaymentAmount, 
        SYSDATE(), 
        vDescription, 
        pActualReceiptDate, 
        pUserId
    );
    
    SET pReceiptId := LAST_INSERT_ID();
    
    -- If full settlement, update loan status and save discount
    IF pIsFullSettlement = 1 THEN
        UPDATE Loan 
        SET LoanStatus = 'B',
            BadLoanDiscount = pSettlementDiscount
        WHERE LoanCode = pLoanCode;
    END IF;
    
    COMMIT;
END//
DELIMITER ;

DELIMITER //
DROP PROCEDURE IF EXISTS `GetFinancialYears`//
CREATE PROCEDURE GetFinancialYears()
BEGIN
    DECLARE vMinYear INT;
    DECLARE vMaxYear INT;
    DECLARE vCurrentYear INT;
    DECLARE vStartDate DATE;
    DECLARE vEndDate DATE;
    
    -- Get min and max years from loan data
    SELECT 
        YEAR(MIN(LoanDate)),
        YEAR(MAX(LoanDate))
    INTO vMinYear, vMaxYear
    FROM Loan;
    
    -- Adjust for financial year (Apr-Mar)
    -- If min loan is before April, FY starts from previous year
    SELECT MIN(LoanDate) INTO vStartDate FROM Loan;
    IF MONTH(vStartDate) < 4 THEN
        SET vMinYear := vMinYear - 1;
    END IF;
    
    -- If max loan is after March, include next FY
    SELECT MAX(LoanDate) INTO vEndDate FROM Loan;
    IF MONTH(vEndDate) >= 4 THEN
        SET vMaxYear := vMaxYear + 1;
    END IF;
    
    -- Create temp table for results
    CREATE TEMPORARY TABLE IF NOT EXISTS TempFY (
        FYCode VARCHAR(10),
        FYDisplay VARCHAR(20),
        StartDate DATE,
        EndDate DATE,
        SortOrder INT
    );
    
    -- Add "Overall" option
    INSERT INTO TempFY VALUES ('OVERALL', 'Overall', '1900-01-01', '2099-12-31', 0);
    
    -- Generate FY list
    SET vCurrentYear := vMinYear;
    WHILE vCurrentYear <= vMaxYear DO
        INSERT INTO TempFY VALUES (
            CONCAT(vCurrentYear, '-', LPAD(vCurrentYear + 1 - 2000, 2, '0')),
            CONCAT('FY ', vCurrentYear, '-', vCurrentYear + 1 - 2000),
            CONCAT(vCurrentYear, '-04-01'),
            CONCAT(vCurrentYear + 1, '-03-31'),
            vCurrentYear
        );
        SET vCurrentYear := vCurrentYear + 1;
    END WHILE;
    
    -- Return results ordered by year
    SELECT FYCode, FYDisplay, StartDate, EndDate 
    FROM TempFY 
    ORDER BY SortOrder DESC;
    
    DROP TEMPORARY TABLE IF EXISTS TempFY;
END//
DELIMITER ;

DELIMITER //
DROP PROCEDURE IF EXISTS `debug_msg`//
CREATE PROCEDURE debug_msg(msg VARCHAR(255))
BEGIN
  select concat('** ', msg) AS '** DEBUG:';
END //
DELIMITER ;



